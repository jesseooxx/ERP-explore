"""
DataWin Report TMP File Parser

Parses .tmp files generated by DataWin ERP's MakeReport.dll
These files contain layout definitions and data for nrp32.exe to render.

File Structure:
1. Header: "Datawin Report.\n" + binary metadata
2. Layout: HEAD/BODY/TAIL sections with PLANK/LABEL/EDIT/LINE/IMAGE blocks
3. Data: Binary records containing page data

Author: Claude Code
"""

import re
import struct
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


@dataclass
class FontStyle:
    """Font style definition"""
    name: str = ""
    size: int = 12
    bold: bool = False
    italic: bool = False
    underline: bool = False

    @classmethod
    def from_string(cls, font_str: str) -> 'FontStyle':
        """Parse font string like: FONT "", 24, PS_FONT_BOLD|PS_FONT_UNDERLINE"""
        style = cls()

        # Extract font name (usually empty "")
        name_match = re.search(r'"([^"]*)"', font_str)
        if name_match:
            style.name = name_match.group(1)

        # Extract size
        size_match = re.search(r',\s*(\d+)', font_str)
        if size_match:
            style.size = int(size_match.group(1))

        # Extract style flags
        style.bold = 'PS_FONT_BOLD' in font_str
        style.italic = 'PS_FONT_ITALIC' in font_str
        style.underline = 'PS_FONT_UNDERLINE' in font_str

        return style


@dataclass
class LayoutItem:
    """Base class for layout items"""
    item_type: str
    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0
    alignment: str = "LEFT"  # LEFT, CENTER, RIGHT
    font: Optional[FontStyle] = None


@dataclass
class LabelItem(LayoutItem):
    """Static label with fixed text"""
    text: str = ""
    label_id: int = 0

    def __post_init__(self):
        self.item_type = "LABEL"


@dataclass
class EditItem(LayoutItem):
    """Dynamic edit field - filled with data at render time"""
    edit_id: int = 0
    dtype: str = "CHAR"  # CHAR, INT, etc.
    dtype_len: int = 0

    def __post_init__(self):
        self.item_type = "EDIT"


@dataclass
class LineItem(LayoutItem):
    """Line drawing element"""
    line_type: int = 0
    x2: int = 0
    y2: int = 0

    def __post_init__(self):
        self.item_type = "LINE"


@dataclass
class ImageItem(LayoutItem):
    """Image element"""
    path: str = ""
    image_id: int = 0

    def __post_init__(self):
        self.item_type = "IMAGE"


@dataclass
class PlankBlock:
    """PLANK block - a positioning container for layout items"""
    plank_id: int
    x: int
    y: int
    width: int
    height: int
    flags: str = ""
    items: List[LayoutItem] = field(default_factory=list)


@dataclass
class LayoutSection:
    """Layout section (HEAD, BODY, or TAIL)"""
    section_type: str  # HEAD, BODY, TAIL
    height: int
    flags: str = ""
    planks: List[PlankBlock] = field(default_factory=list)


@dataclass
class PageData:
    """Data for a single page"""
    page_number: int
    edit_values: Dict[int, str] = field(default_factory=dict)
    raw_texts: List[str] = field(default_factory=list)


@dataclass
class TmpReport:
    """Complete parsed TMP report"""
    # Header info
    version: str = ""

    # Layout sections
    head: Optional[LayoutSection] = None
    body: Optional[LayoutSection] = None
    tail: Optional[LayoutSection] = None

    # Page data
    pages: List[PageData] = field(default_factory=list)

    # Raw content for debugging
    layout_text: str = ""

    @property
    def page_count(self) -> int:
        return len(self.pages)

    def get_all_planks(self) -> List[PlankBlock]:
        """Get all planks from all sections"""
        planks = []
        if self.head:
            planks.extend(self.head.planks)
        if self.body:
            planks.extend(self.body.planks)
        if self.tail:
            planks.extend(self.tail.planks)
        return planks


class TmpParser:
    """Parser for DataWin .tmp report files"""

    def __init__(self):
        self.report = TmpReport()

    def parse_file(self, filepath: str) -> TmpReport:
        """Parse a .tmp file and return TmpReport"""
        filepath = Path(filepath)
        if not filepath.exists():
            raise FileNotFoundError(f"File not found: {filepath}")

        with open(filepath, 'rb') as f:
            data = f.read()

        return self.parse_bytes(data)

    def parse_bytes(self, data: bytes) -> TmpReport:
        """Parse .tmp data from bytes"""
        self.report = TmpReport()

        # 1. Verify header
        if not data.startswith(b'Datawin Report'):
            raise ValueError("Not a valid DataWin Report file")

        self.report.version = "DataWin"

        # 2. Decode as text (ASCII with ignore for binary parts)
        text = data.decode('ascii', errors='ignore')

        # 3. Extract layout definition (between header and data section)
        layout_start = text.find('HEAD ')
        if layout_start < 0:
            layout_start = text.find('HEAD\t')
        if layout_start < 0:
            raise ValueError("No HEAD section found")

        # Find end of layout (after last closing brace of TAIL section)
        layout_end = self._find_layout_end(text, layout_start)
        layout_text = text[layout_start:layout_end]
        self.report.layout_text = layout_text

        # 4. Parse layout sections
        self._parse_layout(layout_text)

        # 5. Extract page data
        self._parse_data(data, layout_end)

        logger.info(f"Parsed report: {len(self.report.get_all_planks())} planks, "
                   f"{self.report.page_count} pages")

        return self.report

    def _find_layout_end(self, text: str, start: int) -> int:
        """Find where layout definition ends"""
        # Find TAIL section and its closing brace
        tail_pos = text.find('TAIL', start)
        if tail_pos < 0:
            # No TAIL, find end of BODY
            body_pos = text.find('BODY', start)
            if body_pos < 0:
                return len(text)
            search_start = body_pos
        else:
            search_start = tail_pos

        # Count braces to find matching close
        brace_count = 0
        in_section = False
        for i, c in enumerate(text[search_start:]):
            if c == '{':
                brace_count += 1
                in_section = True
            elif c == '}':
                brace_count -= 1
                if in_section and brace_count == 0:
                    return search_start + i + 1

        return len(text)

    def _parse_layout(self, layout_text: str):
        """Parse the layout definition text"""
        # Parse HEAD section
        head_match = re.search(r'HEAD\s+(\d+)\s*,?\s*([^\n{]*)\s*\{', layout_text)
        if head_match:
            height = int(head_match.group(1))
            flags = head_match.group(2).strip()
            head_content = self._extract_section_content(layout_text, head_match.end() - 1)
            self.report.head = LayoutSection(
                section_type="HEAD",
                height=height,
                flags=flags,
                planks=self._parse_planks(head_content)
            )

        # Parse BODY section
        body_match = re.search(r'BODY\s+(\d+)\s*,?\s*([^\n{]*)\s*\{', layout_text)
        if body_match:
            height = int(body_match.group(1))
            flags = body_match.group(2).strip()
            body_content = self._extract_section_content(layout_text, body_match.end() - 1)
            self.report.body = LayoutSection(
                section_type="BODY",
                height=height,
                flags=flags,
                planks=self._parse_planks(body_content)
            )

        # Parse TAIL section
        tail_match = re.search(r'TAIL\s+(\d+)\s*,?\s*([^\n{]*)\s*\{', layout_text)
        if tail_match:
            height = int(tail_match.group(1))
            flags = tail_match.group(2).strip()
            tail_content = self._extract_section_content(layout_text, tail_match.end() - 1)
            self.report.tail = LayoutSection(
                section_type="TAIL",
                height=height,
                flags=flags,
                planks=self._parse_planks(tail_content)
            )

    def _extract_section_content(self, text: str, brace_pos: int) -> str:
        """Extract content between matching braces"""
        if text[brace_pos] != '{':
            return ""

        brace_count = 0
        start = brace_pos + 1
        for i, c in enumerate(text[brace_pos:]):
            if c == '{':
                brace_count += 1
            elif c == '}':
                brace_count -= 1
                if brace_count == 0:
                    return text[start:brace_pos + i]

        return text[start:]

    def _parse_planks(self, section_content: str) -> List[PlankBlock]:
        """Parse PLANK blocks from section content"""
        planks = []

        # Pattern: PLANK ID_PLANK+ num, flags, x, y, width, height
        plank_pattern = r'PLANK\s+ID_PLANK\+\s*(\d+)\s*,\s*([^,]+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\{'

        for match in re.finditer(plank_pattern, section_content):
            plank_id = int(match.group(1))
            flags = match.group(2).strip()
            x = int(match.group(3))
            y = int(match.group(4))
            width = int(match.group(5))
            height = int(match.group(6))

            # Extract plank content
            plank_content = self._extract_section_content(section_content, match.end() - 1)

            # Parse items in this plank
            items = self._parse_plank_items(plank_content)

            plank = PlankBlock(
                plank_id=plank_id,
                x=x, y=y,
                width=width, height=height,
                flags=flags,
                items=items
            )
            planks.append(plank)

        return planks

    def _parse_plank_items(self, plank_content: str) -> List[LayoutItem]:
        """Parse items (LABEL, EDIT, LINE, IMAGE) from plank content"""
        items = []

        # Parse LABELs: LABEL "text",ID_LABEL+ num, alignment, x, y, width, height
        label_pattern = r'LABEL\s+"([^"]*)"\s*,\s*ID_LABEL\+\s*(\d+)\s*,\s*(\w+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)'
        for match in re.finditer(label_pattern, plank_content):
            # Decode hex-encoded text if present
            text = match.group(1)
            if all(c in '0123456789ABCDEFabcdef' for c in text) and len(text) % 2 == 0:
                try:
                    text = bytes.fromhex(text).decode('ascii', errors='ignore')
                except:
                    pass

            label = LabelItem(
                item_type="LABEL",
                text=text,
                label_id=int(match.group(2)),
                alignment=self._parse_alignment(match.group(3)),
                x=int(match.group(4)),
                y=int(match.group(5)),
                width=int(match.group(6)),
                height=int(match.group(7))
            )
            items.append(label)

        # Parse EDITs: EDIT ID_EDIT+ num, alignment, x, y, width, height
        edit_pattern = r'EDIT\s+ID_EDIT\+\s*(\d+)\s*,\s*(\w+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)'
        for match in re.finditer(edit_pattern, plank_content):
            edit = EditItem(
                item_type="EDIT",
                edit_id=int(match.group(1)),
                alignment=self._parse_alignment(match.group(2)),
                x=int(match.group(3)),
                y=int(match.group(4)),
                width=int(match.group(5)),
                height=int(match.group(6))
            )

            # Look for DTYPE after this EDIT
            edit_end = match.end()
            dtype_match = re.search(r'DTYPE\s+(\w+)(?:\((\d+)\))?', plank_content[edit_end:edit_end+50])
            if dtype_match:
                edit.dtype = dtype_match.group(1)
                if dtype_match.group(2):
                    edit.dtype_len = int(dtype_match.group(2))

            items.append(edit)

        # Parse LINEs: LINE , type, x1, y1, x2, y2
        line_pattern = r'LINE\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)'
        for match in re.finditer(line_pattern, plank_content):
            line = LineItem(
                item_type="LINE",
                line_type=int(match.group(1)),
                x=int(match.group(2)),
                y=int(match.group(3)),
                x2=int(match.group(4)),
                y2=int(match.group(5))
            )
            items.append(line)

        # Parse IMAGEs: IMAGE "path" ,ID_LABEL+ num, alignment, x, y, width, height
        image_pattern = r'IMAGE\s+"([^"]+)"\s*,\s*ID_LABEL\+\s*(\d+)\s*,\s*(\w+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)'
        for match in re.finditer(image_pattern, plank_content):
            image = ImageItem(
                item_type="IMAGE",
                path=match.group(1),
                image_id=int(match.group(2)),
                alignment=self._parse_alignment(match.group(3)),
                x=int(match.group(4)),
                y=int(match.group(5)),
                width=int(match.group(6)),
                height=int(match.group(7))
            )
            items.append(image)

        # Parse FONT for the plank (applies to all items)
        font_match = re.search(r'FONT\s+"[^"]*"\s*,\s*\d+[^\n]*', plank_content)
        if font_match:
            font = FontStyle.from_string(font_match.group(0))
            for item in items:
                if item.font is None:
                    item.font = font

        return items

    def _parse_alignment(self, align_str: str) -> str:
        """Parse alignment flag"""
        if 'CENTER' in align_str:
            return 'CENTER'
        elif 'RIGHT' in align_str:
            return 'RIGHT'
        else:
            return 'LEFT'

    def _parse_data(self, data: bytes, layout_end: int):
        """Parse the data section to extract page content"""
        # Convert to text for string extraction
        text = data.decode('ascii', errors='ignore')

        # Find all occurrences of key page markers
        # Each page typically starts with "PROFORMA INVOICE" or similar title
        page_markers = ['PROFORMA INVOICE', 'PURCHASE ORDER', 'PACKING LIST', 'INVOICE']

        page_positions = []
        for marker in page_markers:
            for match in re.finditer(re.escape(marker), text[layout_end:]):
                page_positions.append((match.start() + layout_end, marker))

        # Sort by position
        page_positions.sort(key=lambda x: x[0])

        # Remove duplicates that are too close together (within same page)
        filtered_positions = []
        last_pos = -1000
        for pos, marker in page_positions:
            if pos - last_pos > 500:  # Pages are at least 500 chars apart
                filtered_positions.append((pos, marker))
                last_pos = pos

        # Extract text content for each page
        for i, (pos, marker) in enumerate(filtered_positions):
            page = PageData(page_number=i + 1)

            # Determine end of this page's data
            if i + 1 < len(filtered_positions):
                end_pos = filtered_positions[i + 1][0]
            else:
                end_pos = len(text)

            # Extract readable strings from this page's data
            page_text = text[pos:end_pos]
            page.raw_texts = self._extract_strings(page_text)

            self.report.pages.append(page)

        # If no pages found, create one page with all data
        if not self.report.pages:
            page = PageData(page_number=1)
            page.raw_texts = self._extract_strings(text[layout_end:])
            self.report.pages.append(page)

    def _extract_strings(self, text: str, min_len: int = 3) -> List[str]:
        """Extract readable strings from text, filtering out noise"""
        strings = []
        current = ""

        for c in text:
            if c.isprintable() and c not in '\x00\x01\x02\x03':
                current += c
            else:
                if len(current.strip()) >= min_len:
                    strings.append(current.strip())
                current = ""

        if len(current.strip()) >= min_len:
            strings.append(current.strip())

        # Filter out obvious noise
        filtered = []
        for s in strings:
            # Skip if mostly non-printable or looks like hex
            if s and not all(c in '0123456789ABCDEFabcdef' for c in s.replace(' ', '')):
                filtered.append(s)

        return filtered


def parse_tmp_file(filepath: str) -> TmpReport:
    """Convenience function to parse a .tmp file"""
    parser = TmpParser()
    return parser.parse_file(filepath)


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python parser.py <file.tmp>")
        sys.exit(1)

    filepath = sys.argv[1]
    report = parse_tmp_file(filepath)

    print(f"\n=== TMP Report Analysis ===")
    print(f"Pages: {report.page_count}")

    print(f"\n--- HEAD Section ---")
    if report.head:
        print(f"Height: {report.head.height}")
        print(f"Planks: {len(report.head.planks)}")

    print(f"\n--- BODY Section ---")
    if report.body:
        print(f"Height: {report.body.height}")
        print(f"Planks: {len(report.body.planks)}")

    print(f"\n--- TAIL Section ---")
    if report.tail:
        print(f"Height: {report.tail.height}")
        print(f"Planks: {len(report.tail.planks)}")

    print(f"\n--- Page Data ---")
    for page in report.pages[:2]:  # First 2 pages
        print(f"\nPage {page.page_number}:")
        print(f"  Texts: {len(page.raw_texts)}")
        for t in page.raw_texts[:10]:
            print(f"    - {t[:60]}...")
